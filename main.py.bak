from PIL import Image
import itertools, os, struct

# Lets design the header
# headerLength = 8 bits
# fileName string
# fileSize = max 65536 bytes
class Header:
    def __init__(self, fileName, fileSize):
        self.fileName = fileName
        self.fileSize = fileSize

    def toBytes(self):
        packQuery = "20sI"
        return struct.pack(packQuery, 
                           self.fileName.encode(),
                           self.fileSize)

    @staticmethod
    def fromBytes(data):
        packQuery = "20sI"
        headerData = struct.unpack(packQuery, data)
        fileName = headerData[0].decode().strip("\x00")
        fileSize = headerData[1]
        print(fileSize)
        return Header(fileName, fileSize)

# get bits from a byte
def access_bit(data, num):
    base = int(num/8)
    shift = num % 8
    return (data[base] & (1<<shift)) >> shift

# returns a list of bits
def fileToBitArray(f):
    data = bytearray(f.read())
    newData = [access_bit(data,i) for i in range(len(data)*8)]
    return newData

# returns a list of bytes
def bitArrayToByteArray(bits):
    bytes = [sum([byte[b] << b for b in range(0,8)])
                for byte in zip(*(iter(bits),) * 8)
            ]
    return bytes

def encodeData(carrierImage, secretFile):
    carrierPixels = list(carrierImage.getdata())

    #secretBits = fileToBitArray(secretFile)
    secretBits = bytearray(secretFile.read())
    secretFileName = os.path.basename(secretFile.name)
    secretFileSize = os.fstat(secretFile.fileno()).st_size
    header = Header(secretFileName, secretFileSize)

    # Super hacky..
    # Image data comes in a tuple (which is immutable). To modify, I keep 
    # track of the three values in the tuple and make a new tuple to
    # override the previous one LOL. This section also causes the most lag.
    i = 0
    for idx1, pixelList in enumerate(carrierPixels):
        tempPixelList = []
        for idx2, value in enumerate(pixelList):
            value = value & 0xFE
            if (i < len(secretBits)):
                value = value | secretBits[i]
            i = i + 1
            tempPixelList.append(value)
        if (len(tempPixelList) == 4):
            pixelList = (tempPixelList[0], tempPixelList[1], tempPixelList[2], tempPixelList[3])
        else:
            pixelList = (tempPixelList[0], tempPixelList[1], tempPixelList[2])
        carrierPixels[idx1] = pixelList

    newImage = Image.new(carrierImage.mode, carrierImage.size)
    newImage.putdata(carrierPixels)
        
    return newImage

def decodeData(carrierImage):
    carrierPixels = list(carrierImage.getdata())

    secretBits = []

    i = 0
    for pixelList in carrierPixels:
        for value in pixelList:
            if (i < 922048):
                secretBits.append(value & 0x1)
            i = i + 1

    secretFile = open("./out2.bmp", 'wb')
    secretBytes = bitArrayToByteArray(secretBits)
    print(type(secretBytes))
    secretFile.write(bytearray(secretBytes))

if __name__ == "__main__":
    carrierImage = Image.open("./carrier3.png")
    secretFile = open("./secret.bmp", 'rb')
    newCarrierImage = encodeData(carrierImage, secretFile)
    newCarrierImage.save('./out.png')

    #carrierImage = Image.open("./out.png")
    #secretFile = decodeData(carrierImage)
